FindDependencyGraph : After Instruction Selection :  NA 
ingress: [4] 0 00
  m_meter_0
    meter Ingress.meter  256
  m_filter_0
  cond-2(ingress::hdr.ipv4.$valid == 1; => $true, 1 => $false)
    $true: [5]
      ipv4_lpm_0
egress: [6]

DepStagesThruDomFrontier postorder : m_meter_0
DepStagesThruDomFrontier postorder : m_filter_0
DepStagesThruDomFrontier postorder : ipv4_lpm_0
DepStagesThruDomFrontier postorder : cond-2
    Maximum stage number according to dependences: 
      INGRESS: 2
      EGRESS: -1
GRAPH
    cond-2 -- CONTROL_COND_TRUE --> ipv4_lpm_0
    m_meter_0 -- IXBAR_READ --> m_filter_0
    m_filter_0 -- OUTPUT --> ipv4_lpm_0
    m_filter_0 -- ANTI_NEXT_TABLE_DATA --> cond-2
    m_meter_0 -- ANTI_NEXT_TABLE_DATA --> m_filter_0
MIN STAGE INFO
    Each table also indicates its dependency chain length
    First number refers to a dependency chain from which each tables are not split
    Second number refers to a dependency chain from which each tables are split as on  last allocation pass
 Stage #0
     m_meter_0 (Ingress.m_meter) 2 2
 Stage #1
     cond-2 (cond-2) 0 0
	- Edge ANTI_NEXT_TABLE_DATA m_filter_0 ( Ingress.m_filter )
     m_filter_0 (Ingress.m_filter) 1 1
	- Edge IXBAR_READ m_meter_0 ( Ingress.m_meter )
 Stage #2
     ipv4_lpm_0 (Ingress.ipv4_lpm) 0 0
	- Edge OUTPUT m_filter_0 ( Ingress.m_filter )

FindDependencyGraph : Just Before PHV allocation :  NA 
ingress: [4] 0 00
  m_meter_0
    meter Ingress.meter  256
  m_filter_0
  cond-2(ingress::hdr.ipv4.$valid == 1; => $true, 1 => $false)
    $true: [5]
      ipv4_lpm_0
egress: [6]

DepStagesThruDomFrontier postorder : m_meter_0
DepStagesThruDomFrontier postorder : m_filter_0
DepStagesThruDomFrontier postorder : ipv4_lpm_0
DepStagesThruDomFrontier postorder : cond-2
    Maximum stage number according to dependences: 
      INGRESS: 2
      EGRESS: -1
GRAPH
    cond-2 -- CONTROL_COND_TRUE --> ipv4_lpm_0
    m_meter_0 -- IXBAR_READ --> m_filter_0
    m_filter_0 -- OUTPUT --> ipv4_lpm_0
    m_filter_0 -- ANTI_NEXT_TABLE_DATA --> cond-2
    m_meter_0 -- ANTI_NEXT_TABLE_DATA --> m_filter_0
MIN STAGE INFO
    Each table also indicates its dependency chain length
    First number refers to a dependency chain from which each tables are not split
    Second number refers to a dependency chain from which each tables are split as on  last allocation pass
 Stage #0
     m_meter_0 (Ingress.m_meter) 2 2
 Stage #1
     cond-2 (cond-2) 0 0
	- Edge ANTI_NEXT_TABLE_DATA m_filter_0 ( Ingress.m_filter )
     m_filter_0 (Ingress.m_filter) 1 1
	- Edge IXBAR_READ m_meter_0 ( Ingress.m_meter )
 Stage #2
     ipv4_lpm_0 (Ingress.ipv4_lpm) 0 0
	- Edge OUTPUT m_filter_0 ( Ingress.m_filter )

FindDependencyGraph : Before Uninitialized Read Check :  NA 
ingress: [4] 0 00
  m_meter_0
    meter Ingress.meter  256
  m_filter_0
  cond-2(ingress::hdr.ipv4.$valid == 1; => $true, 1 => $false)
    $true: [5]
      ipv4_lpm_0
egress: [6]

	Add container conflict between table m_filter_0 and table ipv4_lpm_0 because of container B4
DepStagesThruDomFrontier postorder : m_meter_0
DepStagesThruDomFrontier postorder : m_filter_0
DepStagesThruDomFrontier postorder : ipv4_lpm_0
DepStagesThruDomFrontier postorder : cond-2
    Maximum stage number according to dependences: 
      INGRESS: 2
      EGRESS: -1
GRAPH
    cond-2 -- CONTROL_COND_TRUE --> ipv4_lpm_0
    m_meter_0 -- IXBAR_READ --> m_filter_0
    m_filter_0 -- OUTPUT --> ipv4_lpm_0
    m_filter_0 -- ANTI_NEXT_TABLE_DATA --> cond-2
    m_meter_0 -- ANTI_NEXT_TABLE_DATA --> m_filter_0
MIN STAGE INFO
    Each table also indicates its dependency chain length
    First number refers to a dependency chain from which each tables are not split
    Second number refers to a dependency chain from which each tables are split as on  last allocation pass
 Stage #0
     m_meter_0 (Ingress.m_meter) 2 2
 Stage #1
     cond-2 (cond-2) 0 0
	- Edge ANTI_NEXT_TABLE_DATA m_filter_0 ( Ingress.m_filter )
     m_filter_0 (Ingress.m_filter) 1 1
	- Edge IXBAR_READ m_meter_0 ( Ingress.m_meter )
 Stage #2
     ipv4_lpm_0 (Ingress.ipv4_lpm) 0 0
	- Edge OUTPUT m_filter_0 ( Ingress.m_filter )

ingress: [4] 1 11
  m_meter_0{ E 22+1, 0 0K }
    meter Ingress.meter  256
  m_filter_0{ E -2+1, 0 0K }
  cond-2(ingress::hdr.ipv4.$valid == 1; => $true, 1 => $false)
    $true: [5]
      ipv4_lpm_0{ T 32+2, 8 4K }
egress: [6]

	Add container conflict between table m_filter_0 and table ipv4_lpm_0 because of container B4
DepStagesThruDomFrontier postorder : m_meter_0
DepStagesThruDomFrontier postorder : m_filter_0
DepStagesThruDomFrontier postorder : ipv4_lpm_0
DepStagesThruDomFrontier postorder : cond-2
    Maximum stage number according to dependences: 
      INGRESS: 2
      EGRESS: -1
GRAPH
    cond-2 -- CONTROL_COND_TRUE --> ipv4_lpm_0
    m_meter_0 -- IXBAR_READ --> m_filter_0
    m_filter_0 -- OUTPUT --> ipv4_lpm_0
    m_filter_0 -- ANTI_NEXT_TABLE_DATA --> cond-2
    m_meter_0 -- ANTI_NEXT_TABLE_DATA --> m_filter_0
MIN STAGE INFO
    Each table also indicates its dependency chain length
    First number refers to a dependency chain from which each tables are not split
    Second number refers to a dependency chain from which each tables are split as on  last allocation pass
 Stage #0
     m_meter_0 (Ingress.m_meter) 2 2
 Stage #1
     cond-2 (cond-2) 0 0
	- Edge ANTI_NEXT_TABLE_DATA m_filter_0 ( Ingress.m_filter )
     m_filter_0 (Ingress.m_filter) 1 1
	- Edge IXBAR_READ m_meter_0 ( Ingress.m_meter )
 Stage #2
     ipv4_lpm_0 (Ingress.ipv4_lpm) 0 0
	- Edge OUTPUT m_filter_0 ( Ingress.m_filter )

FindDependencyGraph : Before Table Placement : INITIAL
ingress: [4] 1 11
  m_meter_0{ E 22+1, 0 0K }
    meter Ingress.meter  256
  m_filter_0{ E -2+1, 0 0K }
  cond-2(ingress::hdr.ipv4.$valid == 1; => $true, 1 => $false)
    $true: [5]
      ipv4_lpm_0{ T 32+2, 8 4K }
egress: [6]

	Add container conflict between table m_filter_0 and table ipv4_lpm_0 because of container B4
DepStagesThruDomFrontier postorder : m_meter_0
DepStagesThruDomFrontier postorder : m_filter_0
DepStagesThruDomFrontier postorder : ipv4_lpm_0
DepStagesThruDomFrontier postorder : cond-2
    Maximum stage number according to dependences: 
      INGRESS: 2
      EGRESS: -1
GRAPH
    cond-2 -- CONTROL_COND_TRUE --> ipv4_lpm_0
    m_meter_0 -- IXBAR_READ --> m_filter_0
    m_filter_0 -- OUTPUT --> ipv4_lpm_0
    m_filter_0 -- ANTI_NEXT_TABLE_DATA --> cond-2
    m_meter_0 -- ANTI_NEXT_TABLE_DATA --> m_filter_0
MIN STAGE INFO
    Each table also indicates its dependency chain length
    First number refers to a dependency chain from which each tables are not split
    Second number refers to a dependency chain from which each tables are split as on  last allocation pass
 Stage #0
     m_meter_0 (Ingress.m_meter) 2 2
 Stage #1
     cond-2 (cond-2) 0 0
	- Edge ANTI_NEXT_TABLE_DATA m_filter_0 ( Ingress.m_filter )
     m_filter_0 (Ingress.m_filter) 1 1
	- Edge IXBAR_READ m_meter_0 ( Ingress.m_meter )
 Stage #2
     ipv4_lpm_0 (Ingress.ipv4_lpm) 0 0
	- Edge OUTPUT m_filter_0 ( Ingress.m_filter )

FindDependencyGraph : After Table Placement : INITIAL
ingress: [4] 0 00
  0: m_meter_0{ E 22+12, 0 [1x3 3K 3K 3K 3K] }
    meter Ingress.meter  256
  10: m_filter_0{ E -2+1, 0 [1x5 5K] }
  20: ipv4_lpm_0(ingress::hdr.ipv4.$valid == 1;, 1 => $false){ GT 32+2, 8 4K }
    $false: [7]
egress: [6]

	Add container conflict between table m_filter_0 and table ipv4_lpm_0 because of container B4
DepStagesThruDomFrontier postorder : m_meter_0
DepStagesThruDomFrontier postorder : m_filter_0
DepStagesThruDomFrontier postorder : ipv4_lpm_0
    Maximum stage number according to dependences: 
      INGRESS: 2
      EGRESS: -1
GRAPH
    m_meter_0 -- IXBAR_READ --> m_filter_0
    m_filter_0 -- OUTPUT --> ipv4_lpm_0
    m_filter_0 -- ANTI_NEXT_TABLE_DATA --> ipv4_lpm_0
    m_meter_0 -- ANTI_NEXT_TABLE_DATA --> m_filter_0
MIN STAGE INFO
    Each table also indicates its dependency chain length
    First number refers to a dependency chain from which each tables are not split
    Second number refers to a dependency chain from which each tables are split as on  last allocation pass
 Stage #0
     m_meter_0 (Ingress.m_meter) 2 2
 Stage #1
     m_filter_0 (Ingress.m_filter) 1 1
	- Edge IXBAR_READ m_meter_0 ( Ingress.m_meter )
 Stage #2
     ipv4_lpm_0 (Ingress.ipv4_lpm) 0 0
	- Edge OUTPUT m_filter_0 ( Ingress.m_filter )

FindDependencyGraph : After Table Placement :  NA 
ingress: [4] 1 11
  0: m_meter_0{ E 22+12, 0 [1x3 3K 3K 3K 3K] }
    meter Ingress.meter 256 
  10: m_filter_0{ E -2+1, 0 [1x5 5K] }
  20: ipv4_lpm_0(ingress::hdr.ipv4.$valid == 1;, 1 => $false){ GT 32+2, 8 4K }
    $false: [7]
egress: [6]

	Add container conflict between table m_filter_0 and table ipv4_lpm_0 because of container B4
DepStagesThruDomFrontier postorder : m_meter_0
DepStagesThruDomFrontier postorder : m_filter_0
DepStagesThruDomFrontier postorder : ipv4_lpm_0
    Maximum stage number according to dependences: 
      INGRESS: 2
      EGRESS: -1
GRAPH
    m_meter_0 -- IXBAR_READ --> m_filter_0
    m_filter_0 -- OUTPUT --> ipv4_lpm_0
    m_filter_0 -- ANTI_NEXT_TABLE_DATA --> ipv4_lpm_0
    m_meter_0 -- ANTI_NEXT_TABLE_DATA --> m_filter_0
MIN STAGE INFO
    Each table also indicates its dependency chain length
    First number refers to a dependency chain from which each tables are not split
    Second number refers to a dependency chain from which each tables are split as on  last allocation pass
 Stage #0
     m_meter_0 (Ingress.m_meter) 2 2
 Stage #1
     m_filter_0 (Ingress.m_filter) 1 1
	- Edge IXBAR_READ m_meter_0 ( Ingress.m_meter )
 Stage #2
     ipv4_lpm_0 (Ingress.ipv4_lpm) 0 0
	- Edge OUTPUT m_filter_0 ( Ingress.m_filter )

FindDependencyGraph : Power Calculation :  NA 
ingress: [4] 1 11
  0: m_meter_0{ E 22+12, 0 [1x3 3K 3K 3K 3K] }
    meter Ingress.meter 256 
  10: m_filter_0{ E -2+1, 0 [1x5 5K] }
  20: ipv4_lpm_0(ingress::hdr.ipv4.$valid == 1;, 1 => $false){ GT 32+2, 8 4K }
    $false: [7]
egress: [6]

	Add container conflict between table m_filter_0 and table ipv4_lpm_0 because of container B4
DepStagesThruDomFrontier postorder : m_meter_0
DepStagesThruDomFrontier postorder : m_filter_0
DepStagesThruDomFrontier postorder : ipv4_lpm_0
    Maximum stage number according to dependences: 
      INGRESS: 2
      EGRESS: -1
GRAPH
    m_meter_0 -- IXBAR_READ --> m_filter_0
    m_filter_0 -- OUTPUT --> ipv4_lpm_0
    m_filter_0 -- ANTI_NEXT_TABLE_DATA --> ipv4_lpm_0
    m_meter_0 -- ANTI_NEXT_TABLE_DATA --> m_filter_0
MIN STAGE INFO
    Each table also indicates its dependency chain length
    First number refers to a dependency chain from which each tables are not split
    Second number refers to a dependency chain from which each tables are split as on  last allocation pass
 Stage #0
     m_meter_0 (Ingress.m_meter) 2 2
 Stage #1
     m_filter_0 (Ingress.m_filter) 1 1
	- Edge IXBAR_READ m_meter_0 ( Ingress.m_meter )
 Stage #2
     ipv4_lpm_0 (Ingress.ipv4_lpm) 0 0
	- Edge OUTPUT m_filter_0 ( Ingress.m_filter )


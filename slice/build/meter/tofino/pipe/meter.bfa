version:
  version: 1.0.1
  run_id: "9a47cfce075f45f7"
  target: Tofino
error_mode: propagate_and_disable
phv ingress:
  hdr.ethernet.dstAddr.0-31: W0
  hdr.ethernet.dstAddr.32-47: H2
  hdr.ethernet.srcAddr.0-31: W1
  hdr.ethernet.srcAddr.32-47: H3
  hdr.ethernet.etherType.0-7: TB8
  hdr.ethernet.etherType.8-15: TB9
  hdr.vlan.pcp: TW2(29..31)
  hdr.vlan.dei: TW2(28)
  hdr.vlan.vid: TW2(16..27)
  hdr.vlan.etherType: TW2(0..15)
  hdr.ipv4.version: TW1(28..31)
  hdr.ipv4.ihl: TW1(24..27)
  hdr.ipv4.diffserv: TW1(18..23)
  hdr.ipv4.ecn: TW1(16..17)
  hdr.ipv4.totalLen: TW1(0..15)
  hdr.ipv4.identification: TW3(16..31)
  hdr.ipv4.flags: TW3(13..15)
  hdr.ipv4.fragOffset: TW3(0..12)
  hdr.ipv4.ttl: B0
  hdr.ipv4.protocol: TB0
  hdr.ipv4.hdrChecksum: TW9(0..15)
  hdr.ipv4.srcAddr: W3
  hdr.ipv4.dstAddr: W2
  hdr.tcp.srcPort: TH3
  hdr.tcp.dstPort: TH2
  hdr.tcp.seqNo: TW8
  hdr.tcp.ackNo.0-15: TH4
  hdr.tcp.ackNo.16-31: TH5
  hdr.tcp.dataOffset: TW0(28..31)
  hdr.tcp.res: TW0(24..27)
  hdr.tcp.cwr: TW0(23)
  hdr.tcp.ece: TW0(22)
  hdr.tcp.urg: TW0(21)
  hdr.tcp.ack: TW0(20)
  hdr.tcp.psh: TW0(19)
  hdr.tcp.rst: TW0(18)
  hdr.tcp.syn: TW0(17)
  hdr.tcp.fin: TW0(16)
  hdr.tcp.window: TW0(0..15)
  hdr.tcp.checksum: TH1
  hdr.tcp.urgentPtr: TH0
  hdr.udp.srcPort: TH1
  hdr.udp.dstPort: TH0
  hdr.udp.len: TW0(16..31)
  hdr.udp.checksum: TW0(0..15)
  hdr.ipv6.version: TW1(28..31)
  hdr.ipv6.diffserv: TW1(22..27)
  hdr.ipv6.ecn: TW1(20..21)
  hdr.ipv6.flowLabel: TW1(0..19)
  hdr.ipv6.PayloadLen: TW2(16..31)
  hdr.ipv6.nextHdr: TW2(8..15)
  hdr.ipv6.hopLimit: TW2(0..7)
  hdr.ipv6.srcAddr.0-15: TH12
  hdr.ipv6.srcAddr.16-23: TB0
  hdr.ipv6.srcAddr.24-31: TB1
  hdr.ipv6.srcAddr.32-47: TH13
  hdr.ipv6.srcAddr.48-63: TH14
  hdr.ipv6.srcAddr.64-79: TH15
  hdr.ipv6.srcAddr.80-95: TH16
  hdr.ipv6.srcAddr.96-111: TH17
  hdr.ipv6.srcAddr.112-119: TB2
  hdr.ipv6.srcAddr.120-127: TB3
  hdr.ipv6.dstAddr.0-31: TW3
  hdr.ipv6.dstAddr.32-63: TW9
  hdr.ipv6.dstAddr.64-95: TW10
  hdr.ipv6.dstAddr.96-127: TW11
  meta.tmp_digest.meterTag: {  stage 1..12: B3 } 
  ig_intr_md_for_dprsr.drop_ctl: {  stage 2..12: B4(0..2) } 
  ig_intr_md_for_dprsr.digest_type: {  stage 1..12: B1(0..2) } 
  ig_intr_md_for_dprsr.mirror_type: {  stage 12: B2(0..2) } 
  ig_intr_md_for_tm.ucast_egress_port: {  stage 3..12: H0(0..8) } 
  $tmp2: {  stage 12: H1(0..9) } 
  hdr.ethernet.$valid: B5(0)
  hdr.vlan.$valid: B5(1)
  hdr.ipv4.$valid: B5(2)
  hdr.tcp.$valid: B5(3)
  hdr.udp.$valid: B5(4)
  hdr.ipv6.$valid: B5(5)
  context_json:
    B0:
    - { name : hdr.ipv4.ttl, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    B1:
    - { name : ig_intr_md_for_dprsr.digest_type, live_start : 1, live_end : deparser, mutually_exclusive_with: [  ] }
    B2:
    - { name : ig_intr_md_for_dprsr.mirror_type, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    B3:
    - { name : meta.tmp_digest.meterTag, live_start : 1, live_end : deparser, mutually_exclusive_with: [  ] }
    B4:
    - { name : ig_intr_md_for_dprsr.drop_ctl, live_start : 2, live_end : deparser, mutually_exclusive_with: [  ] }
    B5:
    - { name : hdr.ethernet.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.vlan.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.ipv4.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.tcp.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.udp.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.ipv6.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    H0:
    - { name : ig_intr_md_for_tm.ucast_egress_port, live_start : 3, live_end : deparser, mutually_exclusive_with: [  ] }
    H1:
    - { name : $tmp2, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    H2:
    - { name : hdr.ethernet.dstAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    H3:
    - { name : hdr.ethernet.srcAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W0:
    - { name : hdr.ethernet.dstAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W1:
    - { name : hdr.ethernet.srcAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W2:
    - { name : hdr.ipv4.dstAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    W3:
    - { name : hdr.ipv4.srcAddr, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
phv egress:
  eg_intr_md.egress_port: H16(0..8)
  hdr.min_parse_depth_padding_0$0.packet_payload.0-31: TW4
  hdr.min_parse_depth_padding_0$0.packet_payload.32-63: TW5
  hdr.min_parse_depth_padding_0$0.packet_payload.64-79: TH18
  hdr.min_parse_depth_padding_0$0.packet_payload.80-87: TB4
  hdr.min_parse_depth_padding_0$1.packet_payload.0-31: TW6
  hdr.min_parse_depth_padding_0$1.packet_payload.32-63: TW7
  hdr.min_parse_depth_padding_0$1.packet_payload.64-79: TH19
  hdr.min_parse_depth_padding_0$1.packet_payload.80-87: TB5
  hdr.min_parse_depth_padding_0$2.packet_payload.0-15: TH6
  hdr.min_parse_depth_padding_0$2.packet_payload.16-31: TH7
  hdr.min_parse_depth_padding_0$2.packet_payload.32-47: TH8
  hdr.min_parse_depth_padding_0$2.packet_payload.48-63: TH9
  hdr.min_parse_depth_padding_0$2.packet_payload.64-79: TH20
  hdr.min_parse_depth_padding_0$2.packet_payload.80-87: TB6
  hdr.min_parse_depth_padding_0$3.packet_payload.0-15: TH10
  hdr.min_parse_depth_padding_0$3.packet_payload.16-31: TH11
  hdr.min_parse_depth_padding_0$3.packet_payload.32-63: TW12
  hdr.min_parse_depth_padding_0$3.packet_payload.64-79: TH21
  hdr.min_parse_depth_padding_0$3.packet_payload.80-87: TB7
  hdr.min_parse_depth_padding_0.$stkvalid: B16(0..3)
  hdr.min_parse_depth_padding_0$0.$valid: {  stage 12: B16(3) } 
  hdr.min_parse_depth_padding_0$1.$valid: {  stage 12: B16(2) } 
  hdr.min_parse_depth_padding_0$2.$valid: {  stage 12: B16(1) } 
  hdr.min_parse_depth_padding_0$3.$valid: B16(0)
  context_json:
    B16:
    - { name : hdr.min_parse_depth_padding_0$3.$valid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.min_parse_depth_padding_0.$stkvalid, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.min_parse_depth_padding_0$0.$valid, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.min_parse_depth_padding_0$1.$valid, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    - { name : hdr.min_parse_depth_padding_0$2.$valid, live_start : deparser, live_end : deparser, mutually_exclusive_with: [  ] }
    H16:
    - { name : eg_intr_md.egress_port, live_start : parser, live_end : deparser, mutually_exclusive_with: [  ] }
parser ingress:
  start: $init_match
  init_zero: [ B3, B4, B2, H1, B5 ]
  bitwise_or: [ B5 ]
  hdr_len_adj: 16
  states:
    $init_match:
      *:
        load: { byte1 : 0 }
        buf_req: 1
        next: $entry_point.start
    $entry_point.start:
      match: [ byte1 ]
      0b1*******:
        shift: 8
        buf_req: 8
        next: end
      0b0*******:
        load: { half : 28..29 }
        shift: 8
        buf_req: 30
        next: TofinoIngressParser_parse_port_metadata
    TofinoIngressParser_parse_port_metadata:
      match: [ half ]
      0x8100:
        8..9: H2  # ingress::hdr.ethernet.dstAddr[47:32].32-47
        10..13: W0  # ingress::hdr.ethernet.dstAddr[31:0].0-31
        14..15: H3  # ingress::hdr.ethernet.srcAddr[47:32].32-47
        16..19: W1  # ingress::hdr.ethernet.srcAddr[31:0].0-31
        20: TB9  # ingress::hdr.ethernet.etherType[15:8].8-15
        21: TB8  # ingress::hdr.ethernet.etherType[7:0].0-7
        B5: 1  # value 1 -> B5 bit[0]: ingress::hdr.ethernet.$valid
        load: { half : 24..25 }
        shift: 22
        buf_req: 26
        next: parse_vlan
      0x0800:
        8..9: H2  # ingress::hdr.ethernet.dstAddr[47:32].32-47
        10..13: W0  # ingress::hdr.ethernet.dstAddr[31:0].0-31
        14..15: H3  # ingress::hdr.ethernet.srcAddr[47:32].32-47
        16..19: W1  # ingress::hdr.ethernet.srcAddr[31:0].0-31
        20: TB9  # ingress::hdr.ethernet.etherType[15:8].8-15
        21: TB8  # ingress::hdr.ethernet.etherType[7:0].0-7
        B5: 1  # value 1 -> B5 bit[0]: ingress::hdr.ethernet.$valid
        shift: 22
        buf_req: 22
        next: parse_ipv4
      0x86dd:
        8..9: H2  # ingress::hdr.ethernet.dstAddr[47:32].32-47
        10..13: W0  # ingress::hdr.ethernet.dstAddr[31:0].0-31
        14..15: H3  # ingress::hdr.ethernet.srcAddr[47:32].32-47
        16..19: W1  # ingress::hdr.ethernet.srcAddr[31:0].0-31
        20: TB9  # ingress::hdr.ethernet.etherType[15:8].8-15
        21: TB8  # ingress::hdr.ethernet.etherType[7:0].0-7
        B5: 1  # value 1 -> B5 bit[0]: ingress::hdr.ethernet.$valid
        shift: 22
        buf_req: 22
        next: parse_ipv6
      0x****:
        8..9: H2  # ingress::hdr.ethernet.dstAddr[47:32].32-47
        10..13: W0  # ingress::hdr.ethernet.dstAddr[31:0].0-31
        14..15: H3  # ingress::hdr.ethernet.srcAddr[47:32].32-47
        16..19: W1  # ingress::hdr.ethernet.srcAddr[31:0].0-31
        20: TB9  # ingress::hdr.ethernet.etherType[15:8].8-15
        21: TB8  # ingress::hdr.ethernet.etherType[7:0].0-7
        B5: 1  # value 1 -> B5 bit[0]: ingress::hdr.ethernet.$valid
        shift: 22
        buf_req: 22
        next: end
    parse_vlan:
      match: [ half ]
      0x0800:
        0..3: TW2
            # - bit[0..2] -> TW2 bit[31..29]: ingress::hdr.vlan.pcp
            # - bit[3] -> TW2 bit[28]: ingress::hdr.vlan.dei
            # - bit[4..15] -> TW2 bit[27..16]: ingress::hdr.vlan.vid
            # - bit[16..31] -> TW2 bit[15..0]: ingress::hdr.vlan.etherType
        B5: 2  # value 1 -> B5 bit[1]: ingress::hdr.vlan.$valid
        shift: 4
        buf_req: 4
        next: parse_ipv4
      0x****:
        0..3: TW2
            # - bit[0..2] -> TW2 bit[31..29]: ingress::hdr.vlan.pcp
            # - bit[3] -> TW2 bit[28]: ingress::hdr.vlan.dei
            # - bit[4..15] -> TW2 bit[27..16]: ingress::hdr.vlan.vid
            # - bit[16..31] -> TW2 bit[15..0]: ingress::hdr.vlan.etherType
        B5: 2  # value 1 -> B5 bit[1]: ingress::hdr.vlan.$valid
        shift: 4
        buf_req: 4
        next: end
    parse_ipv4:
      *:
        0..3: TW1
            # - bit[0..3] -> TW1 bit[31..28]: ingress::hdr.ipv4.version
            # - bit[4..7] -> TW1 bit[27..24]: ingress::hdr.ipv4.ihl
            # - bit[8..13] -> TW1 bit[23..18]: ingress::hdr.ipv4.diffserv
            # - bit[14..15] -> TW1 bit[17..16]: ingress::hdr.ipv4.ecn
            # - bit[16..31] -> TW1 bit[15..0]: ingress::hdr.ipv4.totalLen
        4..7: TW3
            # - bit[32..47] -> TW3 bit[31..16]: ingress::hdr.ipv4.identification
            # - bit[48..50] -> TW3 bit[15..13]: ingress::hdr.ipv4.flags
            # - bit[51..63] -> TW3 bit[12..0]: ingress::hdr.ipv4.fragOffset
        8: B0  # ingress::hdr.ipv4.ttl
        8..11: TW9  # bit[80..95] -> TW9 bit[15..0]: ingress::hdr.ipv4.hdrChecksum
        9: TB0  # ingress::hdr.ipv4.protocol
        12..15: W3  # ingress::hdr.ipv4.srcAddr
        B5: 4  # value 1 -> B5 bit[2]: ingress::hdr.ipv4.$valid
        load: { byte1 : 9 }
        shift: 16
        buf_req: 16
        next: parse_ipv4.$split_0
    parse_ipv4.$split_0:
      match: [ byte1 ]
      0x06:
        0..3: W2  # ingress::hdr.ipv4.dstAddr
        shift: 4
        buf_req: 4
        next: parse_tcp
      0x11:
        0..3: W2  # ingress::hdr.ipv4.dstAddr
        shift: 4
        buf_req: 4
        next: parse_udp
      0x**:
        0..3: W2  # ingress::hdr.ipv4.dstAddr
        shift: 4
        buf_req: 4
        next: end
    parse_tcp:
      *:
        0..1: TH3  # ingress::hdr.tcp.srcPort
        2..3: TH2  # ingress::hdr.tcp.dstPort
        4..7: TW8  # ingress::hdr.tcp.seqNo
        8..9: TH5  # ingress::hdr.tcp.ackNo[31:16].16-31
        10..11: TH4  # ingress::hdr.tcp.ackNo[15:0].0-15
        12..15: TW0
            # - bit[96..99] -> TW0 bit[31..28]: ingress::hdr.tcp.dataOffset
            # - bit[100..103] -> TW0 bit[27..24]: ingress::hdr.tcp.res
            # - bit[104] -> TW0 bit[23]: ingress::hdr.tcp.cwr
            # - bit[105] -> TW0 bit[22]: ingress::hdr.tcp.ece
            # - bit[106] -> TW0 bit[21]: ingress::hdr.tcp.urg
            # - bit[107] -> TW0 bit[20]: ingress::hdr.tcp.ack
            # - bit[108] -> TW0 bit[19]: ingress::hdr.tcp.psh
            # - bit[109] -> TW0 bit[18]: ingress::hdr.tcp.rst
            # - bit[110] -> TW0 bit[17]: ingress::hdr.tcp.syn
            # - bit[111] -> TW0 bit[16]: ingress::hdr.tcp.fin
            # - bit[112..127] -> TW0 bit[15..0]: ingress::hdr.tcp.window
        B5: 8  # value 1 -> B5 bit[3]: ingress::hdr.tcp.$valid
        shift: 16
        buf_req: 16
        next: parse_tcp.$split_0
    parse_tcp.$split_0:
      *:
        0..1: TH1  # ingress::hdr.tcp.checksum
        2..3: TH0  # ingress::hdr.tcp.urgentPtr
        shift: 4
        buf_req: 4
        next: end
    parse_udp:
      *:
        0..1: TH1  # ingress::hdr.udp.srcPort
        2..3: TH0  # ingress::hdr.udp.dstPort
        4..7: TW0
            # - bit[32..47] -> TW0 bit[31..16]: ingress::hdr.udp.len
            # - bit[48..63] -> TW0 bit[15..0]: ingress::hdr.udp.checksum
        B5: 16  # value 1 -> B5 bit[4]: ingress::hdr.udp.$valid
        shift: 8
        buf_req: 8
        next: end
    parse_ipv6:
      *:
        0..3: TW1
            # - bit[0..3] -> TW1 bit[31..28]: ingress::hdr.ipv6.version
            # - bit[4..9] -> TW1 bit[27..22]: ingress::hdr.ipv6.diffserv
            # - bit[10..11] -> TW1 bit[21..20]: ingress::hdr.ipv6.ecn
            # - bit[12..31] -> TW1 bit[19..0]: ingress::hdr.ipv6.flowLabel
        4..7: TW2
            # - bit[32..47] -> TW2 bit[31..16]: ingress::hdr.ipv6.PayloadLen
            # - bit[48..55] -> TW2 bit[15..8]: ingress::hdr.ipv6.nextHdr
            # - bit[56..63] -> TW2 bit[7..0]: ingress::hdr.ipv6.hopLimit
        8: TB3  # ingress::hdr.ipv6.srcAddr[127:120].120-127
        9: TB2  # ingress::hdr.ipv6.srcAddr[119:112].112-119
        10..11: TH17  # ingress::hdr.ipv6.srcAddr[111:96].96-111
        12..13: TH16  # ingress::hdr.ipv6.srcAddr[95:80].80-95
        14..15: TH15  # ingress::hdr.ipv6.srcAddr[79:64].64-79
        16..17: TH14  # ingress::hdr.ipv6.srcAddr[63:48].48-63
        20: TB1  # ingress::hdr.ipv6.srcAddr[31:24].24-31
        21: TB0  # ingress::hdr.ipv6.srcAddr[23:16].16-23
        24..27: TW11  # ingress::hdr.ipv6.dstAddr[127:96].96-127
        28..31: TW10  # ingress::hdr.ipv6.dstAddr[95:64].64-95
        load: { byte1 : 6 }
        shift: 18
        buf_req: 32
        next: parse_ipv6.$split_0
    parse_ipv6.$split_0:
      match: [ byte1 ]
      0x06:
        0..1: TH13  # ingress::hdr.ipv6.srcAddr[47:32].32-47
        4..5: TH12  # ingress::hdr.ipv6.srcAddr[15:0].0-15
        14..17: TW9  # ingress::hdr.ipv6.dstAddr[63:32].32-63
        18..21: TW3  # ingress::hdr.ipv6.dstAddr[31:0].0-31
        B5: 32  # value 1 -> B5 bit[5]: ingress::hdr.ipv6.$valid
        shift: 22
        buf_req: 22
        next: parse_tcp
      0x11:
        0..1: TH13  # ingress::hdr.ipv6.srcAddr[47:32].32-47
        4..5: TH12  # ingress::hdr.ipv6.srcAddr[15:0].0-15
        14..17: TW9  # ingress::hdr.ipv6.dstAddr[63:32].32-63
        18..21: TW3  # ingress::hdr.ipv6.dstAddr[31:0].0-31
        B5: 32  # value 1 -> B5 bit[5]: ingress::hdr.ipv6.$valid
        shift: 22
        buf_req: 22
        next: parse_udp
      0x**:
        0..1: TH13  # ingress::hdr.ipv6.srcAddr[47:32].32-47
        4..5: TH12  # ingress::hdr.ipv6.srcAddr[15:0].0-15
        14..17: TW9  # ingress::hdr.ipv6.dstAddr[63:32].32-63
        18..21: TW3  # ingress::hdr.ipv6.dstAddr[31:0].0-31
        B5: 32  # value 1 -> B5 bit[5]: ingress::hdr.ipv6.$valid
        shift: 22
        buf_req: 22
        next: end
deparser ingress:
  dictionary:
    H2: B5(0)  # ingress::hdr.ethernet.dstAddr.32-47 if ingress::hdr.ethernet.$valid
    W0: B5(0)  # ingress::hdr.ethernet.dstAddr.0-31 if ingress::hdr.ethernet.$valid
    H3: B5(0)  # ingress::hdr.ethernet.srcAddr.32-47 if ingress::hdr.ethernet.$valid
    W1: B5(0)  # ingress::hdr.ethernet.srcAddr.0-31 if ingress::hdr.ethernet.$valid
    TB9: B5(0)  # ingress::hdr.ethernet.etherType.8-15 if ingress::hdr.ethernet.$valid
    TB8: B5(0)  # ingress::hdr.ethernet.etherType.0-7 if ingress::hdr.ethernet.$valid
    TW2: B5(1)
        # - bit[31..29]: ingress::hdr.vlan.pcp if ingress::hdr.vlan.$valid
        # - bit[28]: ingress::hdr.vlan.dei if ingress::hdr.vlan.$valid
        # - bit[27..16]: ingress::hdr.vlan.vid if ingress::hdr.vlan.$valid
        # - bit[15..0]: ingress::hdr.vlan.etherType if ingress::hdr.vlan.$valid
    TW1: B5(2)
        # - bit[31..28]: ingress::hdr.ipv4.version if ingress::hdr.ipv4.$valid
        # - bit[27..24]: ingress::hdr.ipv4.ihl if ingress::hdr.ipv4.$valid
        # - bit[23..18]: ingress::hdr.ipv4.diffserv if ingress::hdr.ipv4.$valid
        # - bit[17..16]: ingress::hdr.ipv4.ecn if ingress::hdr.ipv4.$valid
        # - bit[15..0]: ingress::hdr.ipv4.totalLen if ingress::hdr.ipv4.$valid
    TW3: B5(2)
        # - bit[31..16]: ingress::hdr.ipv4.identification if ingress::hdr.ipv4.$valid
        # - bit[15..13]: ingress::hdr.ipv4.flags if ingress::hdr.ipv4.$valid
        # - bit[12..0]: ingress::hdr.ipv4.fragOffset if ingress::hdr.ipv4.$valid
    B0: B5(2)  # ingress::hdr.ipv4.ttl if ingress::hdr.ipv4.$valid
    TB0: B5(2)  # ingress::hdr.ipv4.protocol if ingress::hdr.ipv4.$valid
    full_checksum 0: B5(2)  # ingress::hdr.ipv4.$valid
    W3: B5(2)  # ingress::hdr.ipv4.srcAddr if ingress::hdr.ipv4.$valid
    W2: B5(2)  # ingress::hdr.ipv4.dstAddr if ingress::hdr.ipv4.$valid
    TW1: B5(5)
        # - bit[31..28]: ingress::hdr.ipv6.version if ingress::hdr.ipv6.$valid
        # - bit[27..22]: ingress::hdr.ipv6.diffserv if ingress::hdr.ipv6.$valid
        # - bit[21..20]: ingress::hdr.ipv6.ecn if ingress::hdr.ipv6.$valid
        # - bit[19..0]: ingress::hdr.ipv6.flowLabel if ingress::hdr.ipv6.$valid
    TW2: B5(5)
        # - bit[31..16]: ingress::hdr.ipv6.PayloadLen if ingress::hdr.ipv6.$valid
        # - bit[15..8]: ingress::hdr.ipv6.nextHdr if ingress::hdr.ipv6.$valid
        # - bit[7..0]: ingress::hdr.ipv6.hopLimit if ingress::hdr.ipv6.$valid
    TB3: B5(5)  # ingress::hdr.ipv6.srcAddr.120-127 if ingress::hdr.ipv6.$valid
    TB2: B5(5)  # ingress::hdr.ipv6.srcAddr.112-119 if ingress::hdr.ipv6.$valid
    TH17: B5(5)  # ingress::hdr.ipv6.srcAddr.96-111 if ingress::hdr.ipv6.$valid
    TH16: B5(5)  # ingress::hdr.ipv6.srcAddr.80-95 if ingress::hdr.ipv6.$valid
    TH15: B5(5)  # ingress::hdr.ipv6.srcAddr.64-79 if ingress::hdr.ipv6.$valid
    TH14: B5(5)  # ingress::hdr.ipv6.srcAddr.48-63 if ingress::hdr.ipv6.$valid
    TH13: B5(5)  # ingress::hdr.ipv6.srcAddr.32-47 if ingress::hdr.ipv6.$valid
    TB1: B5(5)  # ingress::hdr.ipv6.srcAddr.24-31 if ingress::hdr.ipv6.$valid
    TB0: B5(5)  # ingress::hdr.ipv6.srcAddr.16-23 if ingress::hdr.ipv6.$valid
    TH12: B5(5)  # ingress::hdr.ipv6.srcAddr.0-15 if ingress::hdr.ipv6.$valid
    TW11: B5(5)  # ingress::hdr.ipv6.dstAddr.96-127 if ingress::hdr.ipv6.$valid
    TW10: B5(5)  # ingress::hdr.ipv6.dstAddr.64-95 if ingress::hdr.ipv6.$valid
    TW9: B5(5)  # ingress::hdr.ipv6.dstAddr.32-63 if ingress::hdr.ipv6.$valid
    TW3: B5(5)  # ingress::hdr.ipv6.dstAddr.0-31 if ingress::hdr.ipv6.$valid
    TH3: B5(3)  # ingress::hdr.tcp.srcPort if ingress::hdr.tcp.$valid
    TH2: B5(3)  # ingress::hdr.tcp.dstPort if ingress::hdr.tcp.$valid
    TW8: B5(3)  # ingress::hdr.tcp.seqNo if ingress::hdr.tcp.$valid
    TH5: B5(3)  # ingress::hdr.tcp.ackNo.16-31 if ingress::hdr.tcp.$valid
    TH4: B5(3)  # ingress::hdr.tcp.ackNo.0-15 if ingress::hdr.tcp.$valid
    TW0: B5(3)
        # - bit[31..28]: ingress::hdr.tcp.dataOffset if ingress::hdr.tcp.$valid
        # - bit[27..24]: ingress::hdr.tcp.res if ingress::hdr.tcp.$valid
        # - bit[23]: ingress::hdr.tcp.cwr if ingress::hdr.tcp.$valid
        # - bit[22]: ingress::hdr.tcp.ece if ingress::hdr.tcp.$valid
        # - bit[21]: ingress::hdr.tcp.urg if ingress::hdr.tcp.$valid
        # - bit[20]: ingress::hdr.tcp.ack if ingress::hdr.tcp.$valid
        # - bit[19]: ingress::hdr.tcp.psh if ingress::hdr.tcp.$valid
        # - bit[18]: ingress::hdr.tcp.rst if ingress::hdr.tcp.$valid
        # - bit[17]: ingress::hdr.tcp.syn if ingress::hdr.tcp.$valid
        # - bit[16]: ingress::hdr.tcp.fin if ingress::hdr.tcp.$valid
        # - bit[15..0]: ingress::hdr.tcp.window if ingress::hdr.tcp.$valid
    TH1: B5(3)  # ingress::hdr.tcp.checksum if ingress::hdr.tcp.$valid
    TH0: B5(3)  # ingress::hdr.tcp.urgentPtr if ingress::hdr.tcp.$valid
    TH1: B5(4)  # ingress::hdr.udp.srcPort if ingress::hdr.udp.$valid
    TH0: B5(4)  # ingress::hdr.udp.dstPort if ingress::hdr.udp.$valid
    TW0: B5(4)
        # - bit[31..16]: ingress::hdr.udp.len if ingress::hdr.udp.$valid
        # - bit[15..0]: ingress::hdr.udp.checksum if ingress::hdr.udp.$valid
  partial_checksum 0: 
    - TW1: { }
        # - bit[31..28]: ingress::hdr.ipv4.version
        # - bit[27..24]: ingress::hdr.ipv4.ihl
        # - bit[23..18]: ingress::hdr.ipv4.diffserv
        # - bit[17..16]: ingress::hdr.ipv4.ecn
        # - bit[15..0]: ingress::hdr.ipv4.totalLen
    - TW3: { }
        # - bit[31..16]: ingress::hdr.ipv4.identification
        # - bit[15..13]: ingress::hdr.ipv4.flags
        # - bit[12..0]: ingress::hdr.ipv4.fragOffset
    - B0: { swap: 1 }  # ingress::hdr.ipv4.ttl
    - TB0: { }  # ingress::hdr.ipv4.protocol
    - W3: { }  # ingress::hdr.ipv4.srcAddr
    - W2: { }  # ingress::hdr.ipv4.dstAddr
  full_checksum 0: 
    - partial_checksum 0: { }
  egress_unicast_port: H0(0..8)  # bit[8..0]: ingress::ig_intr_md_for_tm.ucast_egress_port
  drop_ctl: B4(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.drop_ctl
  learning:
    select: B1(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.digest_type
    1:
      - B1(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.digest_type
      - B3  # ingress::meta.tmp_digest.meterTag
    context_json:
      1:
        - [ meta.tmp_digest.meterTag, 1, 8, 7, 0]
      name: [ IngressDeparser.digest_inst ]
  mirror:
    select: B2(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.mirror_type
    0:
      - H1(0..9)  # bit[9..0]: ingress::$tmp2
parser egress:
  start: $entry_point.start.min_parse_depth_accept_initial
  init_zero: [ B16 ]
  bitwise_or: [ B16 ]
  hdr_len_adj: 27
  meta_opt: 8191
  states:
    $entry_point.start.min_parse_depth_accept_initial:
      *:
        counter:
          imm: 38
        0..1: H16  # bit[7..15] -> H16 bit[8..0]: egress::eg_intr_md.egress_port
        intr_md: 9
        shift: 27
        buf_req: 27
        next: $entry_point.start.min_parse_depth_accept_initial.$ctr_stall0
    $entry_point.start.min_parse_depth_accept_initial.$ctr_stall0:
      *:
        buf_req: 0
        next: $entry_point.start.min_parse_depth_accept_initial.$split_0
    $entry_point.start.min_parse_depth_accept_initial.$split_0:
      match: [ ctr_neg, ctr_zero ]
      0x0:
        counter: dec 11
        0: TB4  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[87:80].80-87
        1..2: TH18  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[79:64].64-79
        3..6: TW5  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[63:32].32-63
        7..10: TW4  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[31:0].0-31
        B16: 8  # value 8 -> B16 bit[3..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 11
        buf_req: 11
        next: min_parse_depth_accept_loop.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0: TB5  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[87:80].80-87
        1..2: TH19  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[79:64].64-79
        3..6: TW7  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[63:32].32-63
        7..10: TW6  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[31:0].0-31
        B16: 4  # value 4 -> B16 bit[3..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 11
        buf_req: 11
        next: min_parse_depth_accept_loop.$it1.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$it1.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0: TB6  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[87:80].80-87
        1..2: TH20  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[79:64].64-79
        3..4: TH9  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[63:48].48-63
        5..6: TH8  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[47:32].32-47
        7..8: TH7  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[31:16].16-31
        B16: 2  # value 2 -> B16 bit[3..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 9
        buf_req: 9
        next: min_parse_depth_accept_loop.$it2.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$it2.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0..1: TH6  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[15:0].0-15
        2: TB7  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[87:80].80-87
        3..4: TH21  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[79:64].64-79
        5..8: TW12  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[63:32].32-63
        9..10: TH11  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[31:16].16-31
        11..12: TH10  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[15:0].0-15
        B16: 1  # value 1 -> B16 bit[3..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 13
        buf_req: 13
        next: end
      0b**:
        0..1: TH6  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[15:0].0-15
        shift: 2
        buf_req: 2
        next: end
deparser egress:
  dictionary:
    TB4: B16(3)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TH18: B16(3)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TW5: B16(3)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TW4: B16(3)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.0-31 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TB5: B16(2)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH19: B16(2)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TW7: B16(2)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TW6: B16(2)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.0-31 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TB6: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH20: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH9: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.48-63 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH8: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.32-47 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH7: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.16-31 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH6: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.0-15 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TB7: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[3].$valid
    TH21: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[3].$valid
    TW12: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[3].$valid
    TH11: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.16-31 if egress::hdr.min_parse_depth_padding_0[3].$valid
    TH10: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.0-15 if egress::hdr.min_parse_depth_padding_0[3].$valid
  egress_unicast_port: H16(0..8)  # bit[8..0]: egress::eg_intr_md.egress_port
stage 0 ingress:
  phase0_match IngressParser.$PORT_METADATA:
    p4:
      name: IngressParser.$PORT_METADATA
      size: 288
      preferred_match_type: exact
      match_type: exact
    size: 288
    p4_param_order:
      ig_intr_md.ingress_port: { type: exact, size: 9 }
    format: {ig_intr_md: 0..63}
    constant_value: 0
    actions:
      set_port_metadata:
      - handle: 0x20000000
      - p4_param_order: { ig_intr_md: 64 } 
  exact_match m_meter_0 0:
    p4: { name: Ingress.m_meter, size: 256 }
    p4_param_order: 
      hdr.ipv4.srcAddr: { type: exact, size: 32, full_size: 32 }
    row: 7
    bus: 0
    column: [ 2, 3, 4, 5 ]
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
      - { group: 0, index: 10..19, select: 40..51 & 0x0, rams: [[7, 3]] }
      - { group: 0, index: 20..29, select: 40..51 & 0x0, rams: [[7, 4]] }
      - { group: 0, index: 30..39, select: 40..51 & 0x0, rams: [[7, 5]] }
    input_xbar:
      exact group 0: { 0: hdr.ipv4.srcAddr }
      hash 0:
        0..7: random(hdr.ipv4.srcAddr(10..31)) ^ hdr.ipv4.srcAddr(0..7)
        8..9: random(hdr.ipv4.srcAddr(10..31)) ^ hdr.ipv4.srcAddr(8..9)
        11..18: random(hdr.ipv4.srcAddr(10..31)) ^ hdr.ipv4.srcAddr(0..7)
        19: random(hdr.ipv4.srcAddr(10..31)) ^ hdr.ipv4.srcAddr(8)
        10: random(hdr.ipv4.srcAddr(10..31)) ^ hdr.ipv4.srcAddr(9)
        22..29: random(hdr.ipv4.srcAddr(10..31)) ^ hdr.ipv4.srcAddr(0..7)
        20..21: random(hdr.ipv4.srcAddr(10..31)) ^ hdr.ipv4.srcAddr(8..9)
        33..39: random(hdr.ipv4.srcAddr(10..31)) ^ hdr.ipv4.srcAddr(0..6)
        30: random(hdr.ipv4.srcAddr(10..31)) ^ hdr.ipv4.srcAddr(7)
        31..32: random(hdr.ipv4.srcAddr(10..31)) ^ hdr.ipv4.srcAddr(8..9)
      hash group 0:
        table: [0]
        seed: 0x8aac779260
    format: { action(0): 0..0, version(0): 112..115, meter_addr(0): 3..12, meter_pfe(0): 13..13, match(0): [ 58..63, 40..55 ], action(1): 1..1, version(1): 116..119, meter_addr(1): 14..23, meter_pfe(1): 24..24, match(1): [ 82..87, 64..79 ], action(2): 2..2, version(2): 120..123, meter_addr(2): 25..34, meter_pfe(2): 35..35, match(2): [ 106..111, 88..103 ] }
    match: [ hdr.ipv4.srcAddr(10..15), hdr.ipv4.srcAddr(16..23), hdr.ipv4.srcAddr(24..31) ]
    match_group_map: [ [ 0, 1, 2 ] ]
    hit: [  m_filter_0 ]
    miss:  m_filter_0
    action_bus: { 3 : m_meter_0$meter.Ingress.meter color }
    meter: m_meter_0$meter.Ingress.meter(meter_addr, meter_pfe, $DEFAULT)
    meter_color : m_meter_0$meter.Ingress.meter(meter_addr, meter_pfe)
    instruction: m_meter_0(action, $DEFAULT)
    actions:
      Ingress.m_update(0, 1):
      - p4_param_order: { meterIndex: 8 }
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000001
      - next_table: 0
      - { meterIndex: meter_addr }
      - set meta.tmp_digest.meterTag, m_meter_0$meter.Ingress.meter color
      - set ig_intr_md_for_dprsr.digest_type, 1
      - m_meter_0$meter.Ingress.meter(2, meterIndex)
      NoAction(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000002
      - next_table: 0
    default_action: NoAction
  meter m_meter_0$meter.Ingress.meter:
    p4: { name: Ingress.meter, size: 256 }
    row: 15
    logical_bus: S
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    vpns: [ 0, 1 ]
    home_row: 15
    color_maprams:
      row: 7
      bus: 0
      column: 2
      vpns:[ 0 ]
      address: idletime
    type: standard
    count: packets
    per_flow_enable: meter_pfe
stage 1 ingress:
  dependency: match
  exact_match m_filter_0 0:
    p4: { name: Ingress.m_filter, size: 8 }
    p4_param_order: 
      meta.tmp_digest.meterTag: { type: exact, size: 8, full_size: 8 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    input_xbar:
      exact group 0: { 0: meta.tmp_digest.meterTag }
      hash 0:
        0..7: meta.tmp_digest.meterTag
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..0, version(0): 112..115, action(1): 1..1, version(1): 116..119, action(2): 2..2, version(2): 120..123, action(3): 3..3, version(3): 124..127, action(4): 4..4, version(4): 8..11 }
    match_group_map: [ [ 0, 1, 2, 3, 4 ] ]
    hit: [  ipv4_lpm_0 ]
    miss:  ipv4_lpm_0
    instruction: m_filter_0(action, $DEFAULT)
    actions:
      Ingress.drop(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000003
      - next_table: 0
      - set ig_intr_md_for_dprsr.drop_ctl, 1
      NoAction(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000004
      - next_table: 0
    default_action: NoAction
stage 2 ingress:
  dependency: action
  ternary_match ipv4_lpm_0 0:
    p4: { name: Ingress.ipv4_lpm, size: 4096 }
    p4_param_order: 
      hdr.ipv4.dstAddr: { type: lpm, size: 32, full_size: 32 }
    row: [ 0, 1, 2, 3, 4, 5, 6, 7 ]
    bus: [ 0, 0, 0, 0, 0, 0, 0, 0 ]
    column:
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    - 0
    input_xbar:
      ternary group 0: { 0: hdr.ipv4.dstAddr }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x55 }
    gateway:
      name: cond-2
      input_xbar:
        exact group 0: { 2: hdr.ipv4.$valid }
      row: 0
      bus: 0
      unit: 0
      match: { 2: hdr.ipv4.$valid }
      0x1:
        run_table: true
      miss:
        next:  END
      condition: 
        expression: "(hdr.ipv4.$valid == 1)"
        true:  ipv4_lpm_0
        false:  END
    hit: [  END ]
    miss:  END
    indirect: ipv4_lpm_0$tind
  ternary_indirect ipv4_lpm_0$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 0: hdr.ipv4.dstAddr }
    format: { action: 0..1 }
    action: ipv4_lpm_0$action_data($DIRECT, $DEFAULT)
    instruction: ipv4_lpm_0$tind(action, $DEFAULT)
    actions:
      Ingress.ipv4_forward(1, 1):
      - p4_param_order: { dstAddr: 48, port: 9 }
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000005
      - next_table: 0
      - { port: $adf_h0(0..8), dstAddr_1.32-47: $adf_h1(0..15), dstAddr.32-47: dstAddr_1.32-47, dstAddr_1.0-31: $adf_f1(0..31), dstAddr.0-31: dstAddr_1.0-31 }
      - set ig_intr_md_for_tm.ucast_egress_port, port
      - set hdr.ethernet.srcAddr.0-31, hdr.ethernet.dstAddr.0-31
      - set hdr.ethernet.srcAddr.32-47, hdr.ethernet.dstAddr.32-47
      - set hdr.ethernet.dstAddr.0-31, dstAddr.0-31
      - set hdr.ethernet.dstAddr.32-47, dstAddr.32-47
      - add B0, 255, B0
      Ingress.drop(2, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000006
      - next_table: 0
      - {  }
      - set ig_intr_md_for_dprsr.drop_ctl, 1
      NoAction(3, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000007
      - next_table: 0
      - {  }
    default_action: NoAction
  action ipv4_lpm_0$action_data:
    p4: { name: Ingress.ipv4_lpm$action }
    row: 15
    logical_bus: A
    column: [ 0, 1 ]
    vpns: [ 0, 1 ]
    home_row:
    - 15
    format Ingress.ipv4_forward: { $adf_h0: 0..15, $adf_h1: 16..31, $adf_f1: 32..63 }
    action_bus: { 32..33 : $adf_h0, 34..35 : $adf_h1, 100..103 : $adf_f1 }


primitives: "meter.prim.json"
dynhash: "meter.dynhash.json"
